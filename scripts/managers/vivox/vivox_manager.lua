-- Decompilation Error: _glue_flows(node)

-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
-- WARNING: Error occurred during decompilation.
--   Code may be incomplete or incorrect.
local ChatManagerInterface = require("scripts/foundation/managers/chat/chat_manager_interface")
local ChatManagerConstants = require("scripts/foundation/managers/chat/chat_manager_constants")
local PrivilegesManager = require("scripts/managers/privileges/privileges_manager")
local VivoxManager = class("VivoxManager")

VivoxManager.init = function (self)
	self._initialized = false
	self._connected = false
	self._login_state = 0
	self._account_handle = nil
	self._privileges_manager = nil
	self._sessions = {}
	self._join_queue = {}
end

VivoxManager.split_peer_id_display_name = function (self, input)
	local separator = string.find(input, "|")

	if separator and separator < string.len(input) and separator > 1 then
		local peer_id = string.sub(input, 1, separator - 1)
		local displayname = string.sub(input, separator + 1)

		return peer_id, displayname
	end

	return nil
end

VivoxManager.split_session_handle = function (self, input)
	local separator = string.find(input, "~")

	if separator and separator < string.len(input) and separator > 1 then
		local name = string.sub(input, 1, separator - 1)
		local tag = string.sub(input, separator + 1)
		tag = string.match(tag, "(.+)@")

		return name, tag
	end

	return nil
end

VivoxManager.peer_id_from_session_handle = function (self, input)
	return input and string.match(input, "%.(.+)~")
end

VivoxManager.tag_from_session_handle = function (self, input)
	return input and string.match(input, "~(.+)@")
end

VivoxManager.initialize = function (self)
	if rawget(_G, "Vivox") then
		local verbose_chat_log = DevParameters.verbose_chat_log == true

		if Vivox.initialize(verbose_chat_log) then
			self._initialized = true

			Vivox.create_connector()

			self._privileges_manager = PrivilegesManager:new()
		end
	else
		Log.error("VivoxManager", "Vivox not available")
	end
end

VivoxManager.is_initialized = function (self)
	return self._initialized
end

VivoxManager.is_connected = function (self)
	return self._connected
end

VivoxManager.login_state = function (self)
	return self._login_state
end

VivoxManager.is_logged_in = function (self)
	return self:login_state() == ChatManagerConstants.LoginState.LOGGED_IN and self._account_handle ~= nil
end

VivoxManager.login = function (self, peer_id, displayname)
	assert(self:is_initialized() and self:is_connected(), "VivoxManager not connected")

	local login_name = peer_id .. "|" .. displayname

	Vivox.login(login_name)
end

VivoxManager.join_chat_channel = function (self, channel, voice, tag)
	if not self:is_logged_in() then
		return
	end

	assert(tag, "Joining a channel requires a tag")
	self._privileges_manager:communications_privilege(false):next(function (results)
		if results.has_privilege == true then
			local channel_name = channel .. "~" .. tostring(tag)

			if self:is_logged_in() then
				Vivox.add_channel_session(self._account_handle, channel_name, true, voice)
			else
				table.insert(self._join_queue, {
					channel_name,
					true,
					voice
				})
			end
		else
			local error = string.format("Communications privilege denied: %s", results.deny_reason or "Unknown reason")

			Log.error("VivoxManager", "Error joining channel %s: %s", channel, error)
		end
	end):catch(function (error)
		Log.error("VivoxManager", "Error joining channel %s: %s", channel, error)
	end)
end

VivoxManager.leave_channel = function (self, channel_handle)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	if self:is_logged_in() then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-12, warpins: 1 ---
		Vivox.remove_session(channel_handle)

		self._sessions[channel_handle] = nil
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 13-13, warpins: 2 ---
	return
	--- END OF BLOCK #1 ---



end

VivoxManager.connected_chat_channels = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	local channels = {}

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 6-16, warpins: 0 ---
	for channel_handle, channel in pairs(self._sessions) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-8, warpins: 1 ---
		local session_text_state = channel.session_text_state

		if session_text_state and session_text_state == ChatManagerConstants.ChannelConnectionState.CONNECTED then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 14-14, warpins: 1 ---
			channels[channel_handle] = channel
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 15-16, warpins: 4 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 17-17, warpins: 1 ---
	return channels
	--- END OF BLOCK #2 ---



end

VivoxManager.connected_voip_channels = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	local channels = {}

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 6-16, warpins: 0 ---
	for channel_handle, channel in pairs(self._sessions) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 6-8, warpins: 1 ---
		local session_media_state = channel.session_media_state

		if session_media_state and session_media_state == ChatManagerConstants.ChannelConnectionState.CONNECTED then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 14-14, warpins: 1 ---
			channels[channel_handle] = channel
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 15-16, warpins: 4 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 17-17, warpins: 1 ---
	return channels
	--- END OF BLOCK #2 ---



end

VivoxManager.connected_to_chat_channel = function (self, peer_id, tag)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	return self:_connected_to_channel(peer_id, tag, "session_text_state")
	--- END OF BLOCK #0 ---



end

VivoxManager.connected_to_voip_channel = function (self, peer_id, tag)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-6, warpins: 1 ---
	return self:_connected_to_channel(peer_id, tag, "session_media_state")
	--- END OF BLOCK #0 ---



end

VivoxManager._connected_to_channel = function (self, peer_id, tag, state)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-4, warpins: 1 ---
	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 5-27, warpins: 0 ---
	for channel_handle, channel in pairs(self._sessions) do

		-- Decompilation error in this vicinity:
		--- BLOCK #0 5-10, warpins: 1 ---
		local channel_tag = self:tag_from_session_handle(channel_handle)

		if channel_tag == tag then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 11-16, warpins: 1 ---
			local channel_peer_id = self:peer_id_from_session_handle(channel_handle)

			if channel_peer_id == peer_id then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 17-19, warpins: 1 ---
				local session_state = channel[state]

				if session_state and session_state == ChatManagerConstants.ChannelConnectionState.CONNECTED then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 25-25, warpins: 1 ---
					return channel_handle
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---

		FLOW; TARGET BLOCK #1



		-- Decompilation error in this vicinity:
		--- BLOCK #1 26-27, warpins: 6 ---
		--- END OF BLOCK #1 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 28-29, warpins: 1 ---
	return nil
	--- END OF BLOCK #2 ---



end

VivoxManager.send_channel_message = function (self, channel_handle, message_body)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-12, warpins: 1 ---
	assert(self:is_logged_in(), "VivoxManager not logged in")
	Vivox.send_session_message(channel_handle, message_body)

	return
	--- END OF BLOCK #0 ---



end

VivoxManager.update = function (self, dt, t)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	if self._privileges_manager then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 4-9, warpins: 1 ---
		self._privileges_manager:update(dt, t)
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 10-12, warpins: 2 ---
	if not self._last_update then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 13-15, warpins: 1 ---
		self._last_update = 0
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 16-18, warpins: 1 ---
		self._last_update = self._last_update + dt
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #1 ---

	FLOW; TARGET BLOCK #2



	-- Decompilation error in this vicinity:
	--- BLOCK #2 19-22, warpins: 2 ---
	if self._last_update > 0.1 then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 23-27, warpins: 1 ---
		self._last_update = 0

		if self._initialized then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 28-32, warpins: 1 ---
			local message = Vivox.get_message()

			if message then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 33-41, warpins: 1 ---
				assert(message.type, "Vivox message missing type")

				if message.type == Vivox.MessageType_EVENT then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 42-46, warpins: 1 ---
					self:_handle_event(message)
					--- END OF BLOCK #0 ---



				else

					-- Decompilation error in this vicinity:
					--- BLOCK #0 47-51, warpins: 1 ---
					if message.type == Vivox.MessageType_RESPONSE then

						-- Decompilation error in this vicinity:
						--- BLOCK #0 52-55, warpins: 1 ---
						self:_handle_response(message)
						--- END OF BLOCK #0 ---



					end
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #2 ---

	FLOW; TARGET BLOCK #3



	-- Decompilation error in this vicinity:
	--- BLOCK #3 56-56, warpins: 6 ---
	return
	--- END OF BLOCK #3 ---



end

local function login_state(vx_login_state_change_state)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	if vx_login_state_change_state == 0 then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 3-7, warpins: 1 ---
		return ChatManagerConstants.LoginState.LOGGED_OUT
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 8-9, warpins: 1 ---
		if vx_login_state_change_state == 1 then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 10-14, warpins: 1 ---
			return ChatManagerConstants.LoginState.LOGGED_IN
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 15-16, warpins: 1 ---
			if vx_login_state_change_state == 2 then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 17-21, warpins: 1 ---
				return ChatManagerConstants.LoginState.LOGGING_IN
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 22-23, warpins: 1 ---
				if vx_login_state_change_state == 3 then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 24-28, warpins: 1 ---
					return ChatManagerConstants.LoginState.LOGGING_OUT
					--- END OF BLOCK #0 ---



				else

					-- Decompilation error in this vicinity:
					--- BLOCK #0 29-30, warpins: 1 ---
					if vx_login_state_change_state == 4 then

						-- Decompilation error in this vicinity:
						--- BLOCK #0 31-35, warpins: 1 ---
						return ChatManagerConstants.LoginState.RESETTING
						--- END OF BLOCK #0 ---



					else

						-- Decompilation error in this vicinity:
						--- BLOCK #0 36-39, warpins: 1 ---
						return ChatManagerConstants.LoginState.ERROR
						--- END OF BLOCK #0 ---



					end
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 40-40, warpins: 6 ---
	return
	--- END OF BLOCK #1 ---



end

local function session_text_state(vx_session_text_state)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	if vx_session_text_state == 0 then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 3-7, warpins: 1 ---
		return ChatManagerConstants.ChannelConnectionState.DISCONNECTED
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 8-9, warpins: 1 ---
		if vx_session_text_state == 1 then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 10-14, warpins: 1 ---
			return ChatManagerConstants.ChannelConnectionState.CONNECTED
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 15-16, warpins: 1 ---
			if vx_session_text_state == 2 then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 17-21, warpins: 1 ---
				return ChatManagerConstants.ChannelConnectionState.CONNECTING
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 22-23, warpins: 1 ---
				if vx_session_text_state == 3 then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 24-28, warpins: 1 ---
					return ChatManagerConstants.ChannelConnectionState.DISCONNECTING
					--- END OF BLOCK #0 ---



				else

					-- Decompilation error in this vicinity:
					--- BLOCK #0 29-30, warpins: 1 ---
					return nil
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 31-31, warpins: 5 ---
	return
	--- END OF BLOCK #1 ---



end

local function session_media_state(vx_session_media_state)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-2, warpins: 1 ---
	if vx_session_media_state == 1 then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 3-7, warpins: 1 ---
		return ChatManagerConstants.ChannelConnectionState.DISCONNECTED
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 8-9, warpins: 1 ---
		if vx_session_media_state == 2 then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 10-14, warpins: 1 ---
			return ChatManagerConstants.ChannelConnectionState.CONNECTED
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 15-16, warpins: 1 ---
			if vx_session_media_state == 3 then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 17-21, warpins: 1 ---
				return ChatManagerConstants.ChannelConnectionState.RINGING
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 22-23, warpins: 1 ---
				if vx_session_media_state == 6 then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 24-28, warpins: 1 ---
					return ChatManagerConstants.ChannelConnectionState.CONNECTING
					--- END OF BLOCK #0 ---



				else

					-- Decompilation error in this vicinity:
					--- BLOCK #0 29-30, warpins: 1 ---
					if vx_session_media_state == 7 then

						-- Decompilation error in this vicinity:
						--- BLOCK #0 31-35, warpins: 1 ---
						return ChatManagerConstants.ChannelConnectionState.DISCONNECTING
						--- END OF BLOCK #0 ---



					else

						-- Decompilation error in this vicinity:
						--- BLOCK #0 36-37, warpins: 1 ---
						return nil
						--- END OF BLOCK #0 ---



					end
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 38-38, warpins: 6 ---
	return
	--- END OF BLOCK #1 ---



end

VivoxManager.is_mic_muted = function (self)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-3, warpins: 1 ---
	return self._local_audio_info and self._local_audio_info.is_mic_muted
	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 6-6, warpins: 2 ---
	--- END OF BLOCK #1 ---



end

VivoxManager.mute_local_mic = function (self, mute)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-5, warpins: 1 ---
	Vivox.mute_local_mic(mute)

	return
	--- END OF BLOCK #0 ---



end

VivoxManager.channel_text_mute_participant = function (self, channel_handle, participant_uri, mute)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-7, warpins: 1 ---
	Vivox.text_session_set_participant_mute_for_me(channel_handle, participant_uri, mute)

	return
	--- END OF BLOCK #0 ---



end

VivoxManager.channel_voip_mute_participant = function (self, channel_handle, participant_uri, mute)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-7, warpins: 1 ---
	Vivox.audio_session_set_participant_mute_for_me(channel_handle, participant_uri, mute)

	return
	--- END OF BLOCK #0 ---



end

VivoxManager._handle_event = function (self, message)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-9, warpins: 1 ---
	assert(message.event, "Missing event")

	if message.event == Vivox.EventType_LOGIN_STATE_CHANGE then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 10-29, warpins: 1 ---
		assert(message.state, "EventType_LOGIN_STATE_CHANGE missing state")

		local state = login_state(message.state)
		self._login_state = state

		Managers.event:trigger("chat_manager_login_state_change", state)

		if state == ChatManagerConstants.LoginState.LOGGED_IN then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 30-33, warpins: 1 ---
			--- END OF BLOCK #0 ---

			FLOW; TARGET BLOCK #1



			-- Decompilation error in this vicinity:
			--- BLOCK #1 34-45, warpins: 0 ---
			for _, queued_channel in ipairs(self._join_queue) do

				-- Decompilation error in this vicinity:
				--- BLOCK #0 34-43, warpins: 1 ---
				local channel = queued_channel[1]
				local text = queued_channel[2]
				local voice = queued_channel[3]

				Vivox.add_channel_session(self._account_handle, channel, text, voice)
				--- END OF BLOCK #0 ---

				FLOW; TARGET BLOCK #1



				-- Decompilation error in this vicinity:
				--- BLOCK #1 44-45, warpins: 2 ---
				--- END OF BLOCK #1 ---



			end

			--- END OF BLOCK #1 ---

			FLOW; TARGET BLOCK #2



			-- Decompilation error in this vicinity:
			--- BLOCK #2 46-52, warpins: 1 ---
			Vivox.get_local_audio_info()

			local mute = true

			if PLATFORM == "xbs" then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 53-54, warpins: 1 ---
				mute = false
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 55-58, warpins: 1 ---
				if Application.user_setting and Application.user_setting() and Application.user_setting().sound_settings and Application.user_setting().sound_settings.voice_chat then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 77-83, warpins: 1 ---
					mute = Application.user_setting().sound_settings.voice_chat == 0
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end

			--- END OF BLOCK #2 ---

			FLOW; TARGET BLOCK #3



			-- Decompilation error in this vicinity:
			--- BLOCK #3 87-91, warpins: 7 ---
			self:mute_local_mic(mute)
			--- END OF BLOCK #3 ---



		end
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 92-96, warpins: 1 ---
		if message.event == Vivox.EventType_SESSION_ADDED then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 97-128, warpins: 1 ---
			assert(message.session_handle, "EventType_SESSION_ADDED missing session_handle")

			local tag = self:tag_from_session_handle(message.session_handle)
			local session = {}
			session.messages = {}
			session.participants = {}
			session.is_channel = message.is_channel
			session.session_handle = message.session_handle
			session.name = message.name
			session.tag = tag
			self._sessions[message.session_handle] = session

			Managers.event:trigger("chat_manager_added_channel", message.session_handle, session)
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 129-133, warpins: 1 ---
			if message.event == Vivox.EventType_SESSION_REMOVED then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 134-149, warpins: 1 ---
				assert(message.session_handle, "EventType_SESSION_REMOVED missing session_handle")

				self._sessions[message.session_handle] = nil

				Managers.event:trigger("chat_manager_removed_channel", message.session_handle)
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 150-154, warpins: 1 ---
				if message.event == Vivox.EventType_TEXT_STREAM_UPDATED then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 155-170, warpins: 1 ---
					assert(message.session_handle, "EventType_TEXT_STREAM_UPDATED missing session_handle")
					assert(message.session_text_state, "EventType_TEXT_STREAM_UPDATED missing session_text_state")

					local state = session_text_state(message.session_text_state)

					if self._sessions[message.session_handle] then

						-- Decompilation error in this vicinity:
						--- BLOCK #0 171-183, warpins: 1 ---
						self._sessions[message.session_handle].session_text_state = state

						Managers.event:trigger("chat_manager_updated_channel_state", message.session_handle, state)
						--- END OF BLOCK #0 ---



					end
					--- END OF BLOCK #0 ---



				else

					-- Decompilation error in this vicinity:
					--- BLOCK #0 184-188, warpins: 1 ---
					if message.event == Vivox.EventType_MEDIA_STREAM_UPDATED then

						-- Decompilation error in this vicinity:
						--- BLOCK #0 189-200, warpins: 1 ---
						assert(message.session_handle, "EventType_MEDIA_STREAM_UPDATED missing session_handle")
						assert(message.session_media_state, "EventType_MEDIA_STREAM_UPDATED missing session_media_state")
						assert(message.incoming ~= nil, "EventType_MEDIA_STREAM_UPDATED missing incoming flag")

						local state = session_media_state(message.session_media_state)

						--- END OF BLOCK #0 ---

						FLOW; TARGET BLOCK #1



						-- Decompilation error in this vicinity:
						--- BLOCK #1 204-213, warpins: 2 ---
						if self._sessions[message.session_handle] then

							-- Decompilation error in this vicinity:
							--- BLOCK #0 214-232, warpins: 1 ---
							self._sessions[message.session_handle].session_media_state = state
							self._sessions[message.session_handle].incoming = message.incoming

							Managers.event:trigger("voip_manager_updated_channel_state", message.session_handle, state, message.incoming)
							--- END OF BLOCK #0 ---



						end
						--- END OF BLOCK #1 ---



					else

						-- Decompilation error in this vicinity:
						--- BLOCK #0 233-237, warpins: 1 ---
						if message.event == Vivox.EventType_MESSAGE then

							-- Decompilation error in this vicinity:
							--- BLOCK #0 238-246, warpins: 1 ---
							assert(message.session_handle, "EventType_MESSAGE missing session_handle")

							if not self._sessions[message.session_handle] then

								-- Decompilation error in this vicinity:
								--- BLOCK #0 247-247, warpins: 1 ---
								return
								--- END OF BLOCK #0 ---



							end

							--- END OF BLOCK #0 ---

							FLOW; TARGET BLOCK #1



							-- Decompilation error in this vicinity:
							--- BLOCK #1 248-271, warpins: 2 ---
							table.insert(self._sessions[message.session_handle].messages, message)

							local participant = self._sessions[message.session_handle].participants[message.participant_uri]

							Managers.event:trigger("chat_manager_message_recieved", message.session_handle, participant, message)
							--- END OF BLOCK #1 ---



						else

							-- Decompilation error in this vicinity:
							--- BLOCK #0 272-276, warpins: 1 ---
							if message.event == Vivox.EventType_PARTICIPANT_ADDED then

								-- Decompilation error in this vicinity:
								--- BLOCK #0 277-289, warpins: 1 ---
								assert(message.session_handle, "EventType_PARTICIPANT_ADDED missing session_handle")
								assert(message.participant_uri, "EventType_PARTICIPANT_ADDED missing participant_url")

								if not self._sessions[message.session_handle] then

									-- Decompilation error in this vicinity:
									--- BLOCK #0 290-290, warpins: 1 ---
									return
									--- END OF BLOCK #0 ---



								end

								--- END OF BLOCK #0 ---

								FLOW; TARGET BLOCK #1



								-- Decompilation error in this vicinity:
								--- BLOCK #1 291-301, warpins: 2 ---
								local peer_id, displayname = self:split_peer_id_display_name(message.displayname)
								local participant = {
									is_speaking = false,
									is_muted_for_me = false,
									is_moderator_muted = false,
									is_text_muted_for_me = false,
									is_moderator_text_muted = false
								}
								participant.account_name = message.account_name
								participant.participant_uri = message.participant_uri
								participant.displayname = (displayname and displayname) or message.displayname
								participant.peer_id = peer_id
								participant.is_current_user = message.is_current_user
								self._sessions[message.session_handle].participants[message.participant_uri] = participant

								Managers.event:trigger("chat_manager_participant_added", message.session_handle, participant)
								--- END OF BLOCK #1 ---

								FLOW; TARGET BLOCK #2



								-- Decompilation error in this vicinity:
								--- BLOCK #2 305-323, warpins: 2 ---
								--- END OF BLOCK #2 ---



							else

								-- Decompilation error in this vicinity:
								--- BLOCK #0 324-328, warpins: 1 ---
								if message.event == Vivox.EventType_PARTICIPANT_UPDATED then

									-- Decompilation error in this vicinity:
									--- BLOCK #0 329-341, warpins: 1 ---
									assert(message.session_handle, "EventType_PARTICIPANT_UPDATED missing session_handle")
									assert(message.participant_uri, "EventType_PARTICIPANT_UPDATED missing participant_url")

									if not self._sessions[message.session_handle] then

										-- Decompilation error in this vicinity:
										--- BLOCK #0 342-342, warpins: 1 ---
										return
										--- END OF BLOCK #0 ---



									end

									--- END OF BLOCK #0 ---

									FLOW; TARGET BLOCK #1



									-- Decompilation error in this vicinity:
									--- BLOCK #1 343-367, warpins: 2 ---
									local participant = self._sessions[message.session_handle].participants[message.participant_uri]
									participant.is_speaking = message.is_speaking
									participant.is_moderator_muted = message.is_moderator_muted
									participant.is_moderator_text_muted = message.is_moderator_text_muted
									participant.is_muted_for_me = message.is_muted_for_me
									participant.is_text_muted_for_me = message.is_text_muted_for_me

									Managers.event:trigger("chat_manager_participant_update", message.session_handle, participant)
									--- END OF BLOCK #1 ---



								else

									-- Decompilation error in this vicinity:
									--- BLOCK #0 368-372, warpins: 1 ---
									if message.event == Vivox.EventType_PARTICIPANT_REMOVED then

										-- Decompilation error in this vicinity:
										--- BLOCK #0 373-385, warpins: 1 ---
										assert(message.session_handle, "EventType_PARTICIPANT_REMOVED missing session_handle")
										assert(message.participant_uri, "EventType_PARTICIPANT_REMOVED missing participant_url")

										if not self._sessions[message.session_handle] then

											-- Decompilation error in this vicinity:
											--- BLOCK #0 386-386, warpins: 1 ---
											return
											--- END OF BLOCK #0 ---



										end

										--- END OF BLOCK #0 ---

										FLOW; TARGET BLOCK #1



										-- Decompilation error in this vicinity:
										--- BLOCK #1 387-405, warpins: 2 ---
										local session = self._sessions[message.session_handle]
										local participant = session.participants[message.participant_uri]
										session.participants[message.participant_uri] = nil

										Managers.event:trigger("chat_manager_participant_removed", message.session_handle, message.participant_uri, participant)
										--- END OF BLOCK #1 ---



									end
									--- END OF BLOCK #0 ---



								end
								--- END OF BLOCK #0 ---



							end
							--- END OF BLOCK #0 ---



						end
						--- END OF BLOCK #0 ---



					end
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 406-406, warpins: 13 ---
	return
	--- END OF BLOCK #1 ---



end

VivoxManager._handle_response = function (self, message)

	-- Decompilation error in this vicinity:
	--- BLOCK #0 1-9, warpins: 1 ---
	assert(message.response, "Missing response")

	if message.response == Vivox.ResponseType_CONNECTOR_CREATE then

		-- Decompilation error in this vicinity:
		--- BLOCK #0 10-19, warpins: 1 ---
		self._connected = true

		Managers.event:trigger("chat_manager_connected", self._connected)
		--- END OF BLOCK #0 ---



	else

		-- Decompilation error in this vicinity:
		--- BLOCK #0 20-24, warpins: 1 ---
		if message.response == Vivox.ResponseType_ACCOUNT_ANONYMOUS_LOGIN then

			-- Decompilation error in this vicinity:
			--- BLOCK #0 25-31, warpins: 1 ---
			assert(message.account_handle, "ResponseType_ACCOUNT_ANONYMOUS_LOGIN missing account_handle")

			self._account_handle = message.account_handle
			--- END OF BLOCK #0 ---



		else

			-- Decompilation error in this vicinity:
			--- BLOCK #0 32-36, warpins: 1 ---
			if message.response == Vivox.ResponseType_MUTED_LOCAL_MIC then

				-- Decompilation error in this vicinity:
				--- BLOCK #0 37-40, warpins: 1 ---
				Vivox.get_local_audio_info()
				--- END OF BLOCK #0 ---



			else

				-- Decompilation error in this vicinity:
				--- BLOCK #0 41-45, warpins: 1 ---
				if message.response == Vivox.ResponseType_GET_LOCAL_AUDIO_INFO then

					-- Decompilation error in this vicinity:
					--- BLOCK #0 46-55, warpins: 1 ---
					self._local_audio_info = {
						is_mic_muted = message.is_mic_muted,
						is_speaker_muted = message.is_speaker_muted,
						mic_volume = message.mic_volume,
						speaker_volume = message.speaker_volume
					}
					--- END OF BLOCK #0 ---



				end
				--- END OF BLOCK #0 ---



			end
			--- END OF BLOCK #0 ---



		end
		--- END OF BLOCK #0 ---



	end

	--- END OF BLOCK #0 ---

	FLOW; TARGET BLOCK #1



	-- Decompilation error in this vicinity:
	--- BLOCK #1 56-56, warpins: 5 ---
	return
	--- END OF BLOCK #1 ---



end

implements(VivoxManager, ChatManagerInterface)

return VivoxManager
